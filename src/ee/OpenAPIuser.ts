export interface IStringToStringDictionary {
  [key: string]: string;
}
export type StringToStringDictionary = Record<string, any>;
export interface IRecordOfAny {
  [key: string]: any;
}
export type RecordOfAny = Record<string, any>;
export interface Ace {
  deny: boolean;
  _id: string;
  name: string;
  rights: string | number;
}
export interface Base {
  _id: string;
  name: string;
  _created: Date;
  _createdby: string;
  _createdbyid: string;
  _modified: Date;
  _modifiedby: string;
  _modifiedbyid: string;

  _type: string;
  _acl: Ace[];
  _name: string;
  _encrypt: string[];
  _version: number;

}
export interface User extends Base {
  email: string;
  username: string;
  dbusage: number;
  dblocked: boolean;
  newpassword: string;
  federationids: string[];
}
export interface WorkflowParameter {
  name: string;
  type: string; // .NET type, like System.String, System.Int32, System.Boolean, System.object, etc.
  direction: "in" | "out" | "inout";
}
export interface Workflow extends Base {
  Parameters: WorkflowParameter[];
  background: boolean;
  Serializable: boolean;
  Filename: string;
  projectandname: string;
  Xaml: string;
}
export interface Collection {
  name: string;
  type: "collection" | "timeseries";
}
export type CreateCollectionOptions = {
  name: string;
  expireAfterSeconds?: number;
  timeseries?: {
    timeField?: string,
    metaField?: string
  }
}
export type CreateIndexOptions = {
  // required, index paths and type, like { "name": "text", "age": 1, "timstamp": "-1" }
  keypath: IRecordOfAny;
  // optional, options, like { unique: true }
  options?: IRecordOfAny;
  // optional, name will be autogenerated if not provided
  name?: string;
}
export type QueryParams = {
  query: any;
  projection?: IStringToStringDictionary;
  top?: number;
  skip?: number;
  sort?: string | IStringToStringDictionary;
  queryas?: string;
  explain?: boolean;
}
export type CountParams = {
  query: any;
  queryas?: string;
}
export type DistinctParams = {
  query: any;
  field: string;
  queryas?: string;
}
export type AggregateParams = {
  pipeline: any;
  queryas?: string;
  explain?: boolean;
}
export type RunOpenRPAWorkflowParams = {
  // _id of OpenRPA workflow to run
  workflowid: string;
  // otional, Parameters to pass to the workflow
  Parameters?: IRecordOfAny // WorkflowParameter[]; 
  // optional, if true, will wait for workflow to complete and return out Parameters.
  rpc: boolean;
}
export type QueueMessageParams = {
  // Payload to pass to queue
  Payload: any;
  // optional, if true, will wait for receiver to process the message and return the reply payload
  rpc: boolean;
}


// A post request should not contain an id.
export type UserCreationParams = Pick<User, "name" | "email" | "username" | "newpassword">;
export type OpenRPAWorkflowCreationParams = Pick<Workflow, "name" | "background" | "Serializable" | "Filename" | "projectandname" | "Xaml">;

import express from "express";

// src/users/usersController.ts
import {
  Body,
  Controller,
  Delete,
  Get,
  Path,
  Post,
  Put,
  Query,
  Request,
  Route,
  Security,
} from "tsoa";
import { amqpwrapper } from "../amqpwrapper.js";
import { Auth } from "../Auth.js";
import { Config } from "../Config.js";
import { Crypt } from "../Crypt.js";
import { Logger } from "../Logger.js";
import { OpenAPIProxy } from "./OpenAPIProxy.js";
import { Util } from "../Util.js";

@Route("api/v1/me")
export class MeController extends Controller {
  /**
  * Returns the current user
  */
  @Get()
  @Security("oidc")
  public async me(
    @Request() request: express.Request,
  ): Promise<User[]> {
    // @ts-ignore
    delete request.user.nodered;
    // @ts-ignore
    delete request.user._acl;
    // @ts-ignore
    delete request.user._type;
    // @ts-ignore
    delete request.user._encrypt;
    // @ts-ignore
    delete request.user._version;
    // @ts-ignore
    const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in);
    return request.user as any
  }

}
@Route("api/v1/users")
export class UsersController extends Controller {
  /**
   * Return a list of users ( max 100 by default)
   * each users properties are limited to name, username, email, lastseen, Ude GetUser with _id to get all properties
   */
  @Get() @Security("oidc")
  public async GetUsers(
    @Request() request: express.Request,
    @Query() limit?: number,
    @Query() projection?: any
  ): Promise<User[]> {
    const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
    if (typeof projection == "string") projection = JSON.parse(projection);
    if (projection == null) {
      projection = { name: 1, username: 1, email: 1, lastseen: 1 } as any
    }
    return await Config.db.query<User>({ collectionname: "users", query: { "_type": "user" }, top: limit, projection, jwt }, null)
  }
  /**
   * Return a user by _id
   * @param id  _id of user to return
   * @returns User
   */
  @Get("{id}")
  @Security("oidc")
  // @SuccessResponse("204", "No Content")
  public async GetUser(
    @Path() id: string,
    @Request() request: express.Request
  ): Promise<User> {
    try {
      const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
      var res = await Config.db.GetOne<User>({ collectionname: "users", query: { _id: id }, jwt }, null)
      return res;
    } catch (error) {
      Logger.instanse.error("Error in GetUser", error, { cls: "UsersController", func: "GetUser" });
      throw error;
    }
  }

  @Post()
  @Security("oidc")
  public async CreateUser(
    @Body() requestBody: UserCreationParams,
    @Request() request: express.Request
  ): Promise<User> {
    const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
    var item = { ...requestBody, _type: "user" } as User;
    if (item.username == null || item.username == "") {
      if (item.email != null && item.email != "") {
        item.username = item.email;
      }
    }
    return Config.db.InsertOne<User>(item, "users", 1, true, jwt, null)
  }
  @Delete("{id}")
  @Security("oidc")
  public async DeleteUser(
    @Path() id: string,
    @Request() request: express.Request
  ): Promise<void> {
    const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
    await Config.db.DeleteOne(id, "users", false, jwt, null)
  }
}
@Route("api/v1/openrpaworkflows")
export class openrpaworkflowsController extends Controller {
  @Get() @Security("oidc")
  public async GetOpenrpaworkflows(
    @Request() request: express.Request,
    @Query() limit?: number,
    @Query() projection?: any
  ): Promise<Workflow[]> {
    const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
    if (typeof projection == "string") projection = JSON.parse(projection);
    if (projection == null) {
      projection = { name: 1, background: 1, Serializable: 1, projectandname: 1 } as any
    }
    return await Config.db.query<Workflow>({ collectionname: "openrpa", query: { "_type": "workflow" }, top: limit, projection, jwt }, null)
  }

  @Get("{id}")
  @Security("oidc")
  // @SuccessResponse("204", "No Content")
  public async GetOpenRPAWorkflow(
    @Path() id: string,
    @Request() request: express.Request
  ): Promise<Workflow> {
    try {
      const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
      var res = await Config.db.GetOne<Workflow>({ collectionname: "openrpa", query: { _id: id, "_type": "workflow" }, jwt }, null)
      return res;
    } catch (error) {
      Logger.instanse.error("Error in GetOpenRPAWorkflow", error, { cls: "openrpaworkflowsController", func: "GetOpenRPAWorkflow" });
      throw error;
    }
  }

  @Post()
  @Security("oidc")
  public async CreateOpenRPAWorkflow(
    @Body() requestBody: OpenRPAWorkflowCreationParams,
    @Request() request: express.Request
  ): Promise<Workflow> {
    const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
    var item = { ...requestBody, _type: "workflow" } as Workflow;
    return Config.db.InsertOne<Workflow>(item, "openrpa", 1, true, jwt, null)
  }
  @Delete("{id}")
  @Security("oidc")
  public async DeleteOpenRPAWorkflow(
    @Path() id: string,
    @Request() request: express.Request
  ): Promise<void> {
    const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
    await Config.db.DeleteOne(id, "openrpa", false, jwt, null)
  }
}
@Route("api/v1/collections")
export class collectionsController extends Controller {
  @Get() @Security("oidc")
  public async GetCollections(
    @Request() request: express.Request,
    @Query() includesystem?: boolean,
  ): Promise<Collection[]> {
    const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
    if (includesystem == null) includesystem = false;
    var collections = await Config.db.ListCollections(true, Crypt.rootToken());
    collections = collections.filter(x => !x.name.endsWith(".chunks"));
    collections = collections.filter(x => !x.name.endsWith("_hist"));
    if (!includesystem) {
      collections = collections.filter(x => x.name.indexOf("system.") === -1);
    }
    collections.sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: "base" }))
    return collections;
  }

  @Get("{collectionname}")
  @Security("oidc")
  // @SuccessResponse("204", "No Content")
  public async GetCollection(
    @Path() collectionname: string,
    @Request() request: express.Request
  ): Promise<Collection> {
    try {
      var collections = await Config.db.ListCollections(true, Crypt.rootToken());
      return collections.find(x => x.name == collectionname);
    } catch (error) {
      Logger.instanse.error("Error in GetCollection", error, { cls: "collectionsController", func: "GetCollection" });
      throw error;
    }
  }

  @Post()
  @Security("oidc")
  public async CreateCollection(
    @Body() requestBody: CreateCollectionOptions,
    @Request() request: express.Request
  ): Promise<Collection> {
    const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
    const name = requestBody.name;
    delete requestBody.name;
    await Config.db.CreateCollection(name, requestBody, jwt, null);
    if (requestBody.timeseries != null) {
      return { name, type: "timeseries" };
    }
    return { name, type: "collection" };
  }
  @Delete("{collectionname}")
  @Security("oidc")
  public async DropCollection(
    @Path() collectionname: string,
    @Request() request: express.Request
  ): Promise<void> {
    const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
    await Config.db.DropCollection(collectionname, jwt, null)
  }
}
@Route("api/v1/indexes")
export class indexesController extends Controller {
  @Get("{collectionname}") @Security("oidc")
  public async GetIndexes(
    @Request() request: express.Request,
    @Path() collectionname: string,
  ): Promise<any[]> {
    const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
    const indexes = await Config.db.db.collection(collectionname).indexes();
    return indexes;
  }

  @Post("{collectionname}")
  @Security("oidc")
  public async CreateIndex(
    @Body() requestBody: CreateIndexOptions,
    @Path() collectionname: string,
    @Request() request: express.Request
  ): Promise<string> {
    const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
    const name = requestBody.name;
    delete requestBody.name;
    var indexname = await Config.db.createIndex(collectionname, name, requestBody.keypath, requestBody.options, null);
    return indexname;
  }
  @Delete("{collectionname}/{name}")
  @Security("oidc")
  public async DropIndex(
    @Path() collectionname: string,
    @Path() name: string,
    @Request() request: express.Request
  ): Promise<void> {
    const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
    await Config.db.deleteIndex(collectionname, name, null)
  }
}
@Route("api/v1/query")
export class QueryController extends Controller {
  @Post("{collectionname}")
  @Security("oidc")
  // @SuccessResponse("204", "No Content")
  public async Query(
    @Body() requestBody: QueryParams,
    @Path() collectionname: string,
    @Request() request: express.Request
  ): Promise<any[]> {
    try {
      const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
      const options = { collectionname, ...requestBody, jwt };
      if (options.queryas == "string") options.queryas = "";
      if (options.query == "string") options.query = "{}";
      var res = await Config.db.query<any>(options, null)
      return res;
    } catch (error) {
      Logger.instanse.error("Error in Query", error, { cls: "QueryController", func: "Query" });
      throw error;
    }
  }

}
@Route("api/v1/count")
export class CountController extends Controller {
  @Post("{collectionname}")
  @Security("oidc")
  // @SuccessResponse("204", "No Content")
  public async Count(
    @Body() requestBody: CountParams,
    @Path() collectionname: string,
    @Request() request: express.Request
  ): Promise<number> {
    try {
      const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
      const options = { collectionname, ...requestBody, jwt };
      if (options.queryas == "string") options.queryas = "";
      if (options.query == "string") options.query = "{}";
      var res = await Config.db.count(options, null)
      return res;
    } catch (error) {
      Logger.instanse.error("Error in Count", error, { cls: "CountController", func: "Count" });
      throw error;
    }
  }

}
@Route("api/v1/distinct")
export class DistinctController extends Controller {
  @Post("{collectionname}")
  @Security("oidc")
  // @SuccessResponse("204", "No Content")
  public async Distinct(
    @Body() requestBody: DistinctParams,
    @Path() collectionname: string,
    @Request() request: express.Request
  ): Promise<string[]> {
    try {
      const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
      const options = { collectionname, ...requestBody, jwt };
      if (options.queryas == "string") options.queryas = "";
      if (options.query == "string") options.query = "{}";
      var res = await Config.db.distinct(options, null)
      return res;
    } catch (error) {
      Logger.instanse.error("Error in Distinct", error, { cls: "DistinctController", func: "Distinct" });
      throw error;
    }
  }

}
@Route("api/v1/aggregate")
export class AggregateController extends Controller {
  @Post("{collectionname}")
  @Security("oidc")
  // @SuccessResponse("204", "No Content")
  public async Aggregate(
    @Body() requestBody: AggregateParams,
    @Path() collectionname: string,
    @Request() request: express.Request
  ): Promise<any[]> {
    try {
      const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
      if (requestBody.queryas == "string") requestBody.queryas = "";
      if (requestBody.pipeline == "string") requestBody.pipeline = "[]";
      var res = await Config.db.aggregate<any>(requestBody.pipeline, collectionname, jwt, null, requestBody.queryas, requestBody.explain, null)
      return res;
    } catch (error) {
      Logger.instanse.error("Error in Aggregate", error, { cls: "AggregateController", func: "Aggregate" });
      throw error;
    }
  }

}
@Route("api/v1/runopenrpaworkflow")
export class RunOpenRPAWorkflowController extends Controller {
  @Post("{robotname}")
  @Security("oidc")
  // @SuccessResponse("204", "No Content")
  public async RunOpenRPAWorkflow(
    @Body() requestBody: RunOpenRPAWorkflowParams,
    @Path() robotname: string,
    @Request() request: express.Request
  ): Promise<IRecordOfAny> {
    try {
      const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);

      var robotuser = null;
      if (robotname != null && robotname != "") {
        robotuser = await Config.db.getbyid(robotname, "users", jwt, true, null)
        if (robotuser == null) {
          robotuser = await Config.db.GetOne({
            collectionname: "users", query: {
              "_type": "user",
              "$or": [{ "name": { "$regex": "^" + robotname + "$", "$options": "i" } },
              { "username": { "$regex": "^" + robotname + "$", "$options": "i" } }]
            }, jwt
          }, null);
        }
      }
      if (robotuser == null) throw new Error("Robot " + robotname + " not found");
      var workflow = null;
      if (requestBody.workflowid != null && requestBody.workflowid != "") {
        workflow = await Config.db.getbyid(requestBody.workflowid, "openrpa", jwt, true, null)
        if (workflow == null) {
          workflow = await Config.db.GetOne({
            collectionname: "openrpa", query: {
              "_type": "workflow",
              "$or": [{ "name": { "$regex": "^" + requestBody.workflowid + "$", "$options": "i" } },
              { "projectandname": { "$regex": "^" + requestBody.workflowid + "$", "$options": "i" } }]
            }, jwt
          }, null);
        }
      }
      if (workflow == null) throw new Error("Workflow " + requestBody.workflowid + " not found");
      const rpacommand = {
        command: "invoke",
        workflowid: workflow._id,
        data: requestBody.Parameters
      }

      if (requestBody.rpc) {
        const { correlationId, promise } = OpenAPIProxy.createPromise();
        Logger.instanse.debug("RPC a message to " + robotname + " with correlationId: " + correlationId + " and message: " + JSON.stringify(rpacommand), null, { cls: "OpenAPIProxy", func: "RunOpenRPAWorkflow" });
        await amqpwrapper.Instance().sendWithReplyTo("", robotuser._id, "openapi", rpacommand, 5000, correlationId, "", null);
        var result = await promise;
        return result as any;
      } else {
        const correlationId = Util.GetUniqueIdentifier();
        Logger.instanse.debug("Send message to " + robotname + " with correlationId: " + correlationId + " and message: " + JSON.stringify(rpacommand), null, { cls: "OpenAPIProxy", func: "RunOpenRPAWorkflow" });
        await amqpwrapper.Instance().send("", robotuser._id, rpacommand, 5000, correlationId, "", null);
        return { correlationId };
      }
    } catch (error) {
      Logger.instanse.error("Error in RunOpenRPAWorkflow", error, { cls: "RunOpenRPAWorkflowController", func: "RunOpenRPAWorkflow" });
      throw error;
    }
  }

}
@Route("api/v1/queuemessage")
export class QueueMessageController extends Controller {
  @Post("{queuename}")
  @Security("oidc")
  // @SuccessResponse("204", "No Content")
  public async QueueMessage(
    @Body() requestBody: QueueMessageParams,
    @Path() queuename: string,
    @Request() request: express.Request
  ): Promise<IRecordOfAny> {
    try {
      const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
      if (queuename == null || queuename == "") {
        throw new Error("Queue name must be specified");
      }
      var payload = requestBody.Payload;

      if (requestBody.rpc) {
        const { correlationId, promise } = OpenAPIProxy.createPromise();
        Logger.instanse.debug("RPC a message to " + queuename + " with correlationId: " + correlationId + " and message: " + JSON.stringify(payload), null, { cls: "OpenAPIProxy", func: "QueueMessage" });
        await amqpwrapper.Instance().sendWithReplyTo("", queuename, "openapi", payload, 5000, correlationId, "", null);
        var result = await promise;
        return result as any;
      } else {
        const correlationId = Util.GetUniqueIdentifier();
        Logger.instanse.debug("Send message to " + queuename + " with correlationId: " + correlationId + " and message: " + JSON.stringify(payload), null, { cls: "OpenAPIProxy", func: "QueueMessage" });
        await amqpwrapper.Instance().send("", queuename, payload, 5000, correlationId, "", null);
        return { correlationId };
      }
    } catch (error) {
      Logger.instanse.error("Error in QueueMessage", error, { cls: "QueueMessageController", func: "QueueMessage" });
      throw error;
    }
  }

}



@Route("api/v1/entities")
export class EntitiesController extends Controller {





  @Post("{collectionname}")
  @Security("oidc")
  public async CreateEntities(
    @Body() requestBody: IRecordOfAny,
    @Path() collectionname: string,
    @Request() request: express.Request
  ): Promise<IRecordOfAny> {
    const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
    var item = { ...requestBody } as IRecordOfAny;
    return Config.db.InsertOne<any>(item, collectionname, 1, true, jwt, null)
  }
  @Put("{collectionname}")
  @Security("oidc")
  public async UpdateEntities(
    @Body() requestBody: IRecordOfAny,
    @Path() collectionname: string,
    @Request() request: express.Request
  ): Promise<any> {
    const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
    var item = { ...requestBody } as any;
    let result = await Config.db.UpdateOne(item, collectionname, 1, true, jwt, null);
    return result.item;
  }
  @Delete("{collectionname}/{id}")
  @Security("oidc")
  public async DeleteEntities(
    @Path() id: string,
    @Path() collectionname: string,
    @Request() request: express.Request
  ): Promise<number> {
    const jwt = await Auth.User2Token(request.user as any, Config.shorttoken_expires_in, null);
    return await Config.db.DeleteOne(id, collectionname, false, jwt, null);
  }
}